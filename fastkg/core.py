"""Utilites for building semantic knowledge graphs in rdflib using a fast.ai approach"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../00_core.ipynb.

# %% auto 0
__all__ = ['KnowledgeGraph']

# %% ../00_core.ipynb 5
import rdflib
import pandas as pd
import pyarrow as pa
from fastcore.all import *
from pathlib import Path
from typing import Union, List, Dict, Any, IO


# %% ../00_core.ipynb 6
class KnowledgeGraph:
    "RDFLib wrapper with Parquet storage capabilities"
    _COL_NAMES = ["subject", "predicate", "object"]
    
    def __init__(self, g=None): 
        self.g = ifnone(g, rdflib.Graph())
    
    def __len__(self): return len(self.g)
    
    def __repr__(self): return f"KnowledgeGraph(triples={len(self)})"

    @delegates(pd.DataFrame.to_parquet)
    def save_parquet(self, path, compression="snappy", **kwargs):
        "Save RDF graph to Parquet file"
        rows = [{self._COL_NAMES[i]:o.n3() for i,o in enumerate(triple)} 
                for triple in self.g]
        df = pd.DataFrame(rows, columns=self._COL_NAMES)
        df.to_parquet(path, compression=compression, **kwargs)

    @delegates(pd.read_parquet)
    def load_parquet(self, path, batch_size=100000, **kwargs):
        "Load RDF graph from Parquet file with optimized performance"
        df = pd.read_parquet(path, **kwargs)
        total = len(df)
        
        # Process in batches to handle large graphs
        for start in range(0, total, batch_size):
            end = min(start + batch_size, total)
            batch = df.iloc[start:end]
            
            # Direct triple creation instead of parsing
            triples = []
            for _, row in batch.iterrows():
                s_str, p_str, o_str = row['subject'], row['predicate'], row['object']
                
                # Parse subject (URI or blank node)
                if s_str.startswith('<') and s_str.endswith('>'):
                    s = rdflib.URIRef(s_str[1:-1])
                elif s_str.startswith('_:'):
                    s = rdflib.BNode(s_str[2:])
                else:
                    s = rdflib.Literal(s_str)
                    
                # Parse predicate (always URI)
                if p_str.startswith('<') and p_str.endswith('>'):
                    p = rdflib.URIRef(p_str[1:-1])
                else:
                    p = rdflib.URIRef(p_str)
                    
                # Parse object (URI, blank node, or literal)
                if o_str.startswith('<') and o_str.endswith('>'):
                    o = rdflib.URIRef(o_str[1:-1])
                elif o_str.startswith('_:'):
                    o = rdflib.BNode(o_str[2:])
                elif o_str.startswith('"') or o_str.startswith("'"):
                    # This is a simplified approach - full N3 parsing is complex
                    # For production, consider using rdflib's parser directly
                    o = rdflib.Literal(o_str)
                else:
                    o = rdflib.Literal(o_str)
                    
                triples.append((s, p, o))
            
            # Add all triples in one batch
            self.g.addN((s, p, o, self.g) for s, p, o in triples)
        
        return self

    


# %% ../00_core.ipynb 7
@patch
def add(self:KnowledgeGraph, triple):
    "Add a triple to the graph"
    self.g.add(triple)
    return self

# %% ../00_core.ipynb 8
@patch
def remove(self:KnowledgeGraph, triple):
    "Remove a triple from the graph"
    self.g.remove(triple)
    return self

# %% ../00_core.ipynb 9
@patch
def bind_ns(self:KnowledgeGraph, prefix, namespace):
    "Bind a namespace prefix"
    self.g.namespace_manager.bind(prefix, namespace)
    return self

# %% ../00_core.ipynb 10
@patch
def bind_namespaces(self:KnowledgeGraph, ns_dict):
    "Bind multiple namespace prefixes"
    for prefix, uri in ns_dict.items():
        ns = rdflib.Namespace(uri)
        self.g.namespace_manager.bind(prefix, ns)
    return self

# %% ../00_core.ipynb 11
@patch
def query(self:KnowledgeGraph, q):
    "Run a SPARQL query"
    return self.g.query(q)

# %% ../00_core.ipynb 12
@patch
def triples(self:KnowledgeGraph, pattern=None):
    "Return triples matching the pattern"
    pattern = ifnone(pattern, (None, None, None))
    return list(self.g.triples(pattern))

# %% ../00_core.ipynb 13
@patch
def __getitem__(self:KnowledgeGraph, pattern):
    "Get triples matching a pattern using [] syntax"
    return list(self.g.triples(pattern))

@patch
def from_file(self:KnowledgeGraph, path, format=None):
    "Load graph from a file in any RDFLib-supported format"
    if format is None:
        format = Path(path).suffix.lstrip('.')
    self.g.parse(path, format=format)
    return self

@patch
def to_file(self:KnowledgeGraph, path, format=None):
    "Save graph to a file in any RDFLib-supported format"
    if format is None:
        format = Path(path).suffix.lstrip('.')
    self.g.serialize(destination=path, format=format)
    return self

@patch
def summary(self:KnowledgeGraph):
    "Print a summary of the graph"
    n_triples = len(self)
    n_subjects = len(set(s for s,_,_ in self.g))
    n_predicates = len(set(p for _,p,_ in self.g))
    n_objects = len(set(o for _,_,o in self.g))
    return dict(triples=n_triples, subjects=n_subjects, 
                predicates=n_predicates, objects=n_objects)

