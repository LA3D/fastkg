# sqlite


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

# RDFLib Parquet Storage

This module provides a fast, efficient way to store and retrieve RDF
graphs using Parquet files. It wraps RDFLib’s graph functionality with
optimized Parquet serialization methods.

## Key Features

- Save RDF graphs to compressed Parquet files
- Load graphs from Parquet with optimized performance
- Preserve all RDF semantics (URIs, blank nodes, literals with
  datatypes)
- Memory-efficient batch processing for large graphs
- Fluent API for method chaining
- Simple integration with existing RDFLib code

## Use Cases

- Store large knowledge graphs efficiently
- Improve load/save times for RDF data
- Integrate semantic web data with data science pipelines
- Reduce storage requirements for RDF datasets
- Enable faster querying through columnar storage benefits

This module bridges the gap between semantic web technologies and modern
data engineering practices, allowing RDF data to benefit from Parquet’s
columnar storage format advantages including compression, schema
enforcement, and performance.

This is inspired by KGLabs implimentation [Performance analysis of
serialization
methods¶](https://derwen.ai/docs/kgl/ex2_0/#performance-analysis-of-serialization-methods)
that showed parquet to be a reasonable triple store for local graphs.
This also provides some convenience functions for constructing KGs.

------------------------------------------------------------------------

<a href="https://github.com/la3d/fastkg/blob/main/fastkg/sqlite.py#L18"
target="_blank" style="float:right; font-size:smaller">source</a>

### SQLiteStore

>  SQLiteStore (configuration=None)

*Simple SQLite-based triple store for RDFLib*

------------------------------------------------------------------------

<a href="https://github.com/la3d/fastkg/blob/main/fastkg/sqlite.py#L216"
target="_blank" style="float:right; font-size:smaller">source</a>

### KnowledgeGraph.connect_sqlite

>  KnowledgeGraph.connect_sqlite (db_path, create=True)

*Connect to a SQLite database file*

------------------------------------------------------------------------

<a href="https://github.com/la3d/fastkg/blob/main/fastkg/sqlite.py#L230"
target="_blank" style="float:right; font-size:smaller">source</a>

### KnowledgeGraph.close

>  KnowledgeGraph.close ()

*Close the database connection if using a persistent store*

``` python
# Step 1: Test basic functionality
db_path = "test_sqlite_store.db"
remove_test_db(db_path)  # Clean up any existing test database

# Create a new store
store = SQLiteStore()

# Open the store
result = store.open(db_path, create=True)
print(f"Open result: {result}")

# Add a triple
test_triple = (
    URIRef("http://example.org/subject"),
    URIRef("http://example.org/predicate"),
    Literal("test object")
)
store.add(test_triple)

# Check if the triple was added
print(f"Store length: {len(store)}")

# Query for the triple
results = list(store.triples((None, None, None)))
print(f"All triples: {results}")

# Close the store
store.close()
```

    Open result: 1
    Store length: 1
    All triples: [((rdflib.term.URIRef('http://example.org/subject'), rdflib.term.URIRef('http://example.org/predicate'), rdflib.term.Literal('test object')), None)]

``` python
# Step 2: Test query patterns
store = SQLiteStore()
store.open(db_path)

# Add more triples for testing queries
store.add((
    URIRef("http://example.org/subject"),
    URIRef("http://example.org/another-predicate"),
    Literal("another object")
))

store.add((
    URIRef("http://example.org/another-subject"),
    URIRef("http://example.org/predicate"),
    Literal("third object")
))

# Query with subject pattern
print("Query with subject pattern:")
results = list(store.triples((URIRef("http://example.org/subject"), None, None)))
for triple, ctx in results:
    print(f"  {triple}")

# Query with predicate pattern
print("\nQuery with predicate pattern:")
results = list(store.triples((None, URIRef("http://example.org/predicate"), None)))
for triple, ctx in results:
    print(f"  {triple}")

# Query with object pattern
print("\nQuery with object pattern:")
results = list(store.triples((None, None, Literal("test object"))))
for triple, ctx in results:
    print(f"  {triple}")

# Query with subject-predicate pattern
print("\nQuery with subject-predicate pattern:")
results = list(store.triples((
    URIRef("http://example.org/subject"),
    URIRef("http://example.org/predicate"),
    None
)))
for triple, ctx in results:
    print(f"  {triple}")

store.close()
```

    Query with subject pattern:
      (rdflib.term.URIRef('http://example.org/subject'), rdflib.term.URIRef('http://example.org/another-predicate'), rdflib.term.Literal('another object'))
      (rdflib.term.URIRef('http://example.org/subject'), rdflib.term.URIRef('http://example.org/predicate'), rdflib.term.Literal('test object'))

    Query with predicate pattern:
      (rdflib.term.URIRef('http://example.org/subject'), rdflib.term.URIRef('http://example.org/predicate'), rdflib.term.Literal('test object'))
      (rdflib.term.URIRef('http://example.org/another-subject'), rdflib.term.URIRef('http://example.org/predicate'), rdflib.term.Literal('third object'))

    Query with object pattern:
      (rdflib.term.URIRef('http://example.org/subject'), rdflib.term.URIRef('http://example.org/predicate'), rdflib.term.Literal('test object'))

    Query with subject-predicate pattern:
      (rdflib.term.URIRef('http://example.org/subject'), rdflib.term.URIRef('http://example.org/predicate'), rdflib.term.Literal('test object'))

``` python
# Step 3: Test different RDF term types
store = SQLiteStore()
store.open(db_path)

# Add triples with different term types
# Blank node
bnode = BNode()
store.add((bnode, URIRef("http://example.org/type"), Literal("blank node")))

# Literal with language tag
store.add((
    URIRef("http://example.org/subject"),
    URIRef("http://example.org/label"),
    Literal("hello", lang="en")
))

# Literal with datatype
store.add((
    URIRef("http://example.org/subject"),
    URIRef("http://example.org/age"),
    Literal("42", datatype=URIRef("http://www.w3.org/2001/XMLSchema#integer"))
))

# Query for specific term types
print("Blank node triples:")
for triple, ctx in store.triples((None, URIRef("http://example.org/type"), None)):
    print(f"  {triple}")
    print(f"  Subject type: {type(triple[0])}")

print("\nLanguage-tagged literal:")
for triple, ctx in store.triples((None, URIRef("http://example.org/label"), None)):
    print(f"  {triple}")
    print(f"  Object language: {triple[2].language}")

print("\nDatatyped literal:")
for triple, ctx in store.triples((None, URIRef("http://example.org/age"), None)):
    print(f"  {triple}")
    print(f"  Object datatype: {triple[2].datatype}")

store.close()
```

    Blank node triples:
      (rdflib.term.BNode('Nc109a8aa596b4894b86367280c0726cc'), rdflib.term.URIRef('http://example.org/type'), rdflib.term.Literal('blank node'))
      Subject type: <class 'rdflib.term.BNode'>

    Language-tagged literal:
      (rdflib.term.URIRef('http://example.org/subject'), rdflib.term.URIRef('http://example.org/label'), rdflib.term.Literal('hello', lang='en'))
      Object language: en

    Datatyped literal:
      (rdflib.term.URIRef('http://example.org/subject'), rdflib.term.URIRef('http://example.org/age'), rdflib.term.Literal('42', datatype=rdflib.term.URIRef('http://www.w3.org/2001/XMLSchema#integer')))
      Object datatype: http://www.w3.org/2001/XMLSchema#integer

``` python
# Step 4: Test removal
store = SQLiteStore()
store.open(db_path)

# Count triples before removal
print(f"Triples before removal: {len(store)}")

# Remove a specific triple
store.remove((
    URIRef("http://example.org/subject"),
    URIRef("http://example.org/predicate"),
    Literal("test object")
))

print(f"Triples after specific removal: {len(store)}")

# Remove triples matching a pattern
store.remove((URIRef("http://example.org/subject"), None, None))

print(f"Triples after pattern removal: {len(store)}")

# Check remaining triples
print("Remaining triples:")
for triple, ctx in store.triples((None, None, None)):
    print(f"  {triple}")

store.close()
```

    Triples before removal: 6
    Triples after specific removal: 5
    Triples after pattern removal: 2
    Remaining triples:
      (rdflib.term.URIRef('http://example.org/another-subject'), rdflib.term.URIRef('http://example.org/predicate'), rdflib.term.Literal('third object'))
      (rdflib.term.BNode('Nc109a8aa596b4894b86367280c0726cc'), rdflib.term.URIRef('http://example.org/type'), rdflib.term.Literal('blank node'))

``` python
# Test with KnowledgeGraph
kg_db_path = "test_kg_sqlite.db"
remove_test_db(kg_db_path)  # Clean up any existing test database

# Create a new graph
kg = KnowledgeGraph()
kg.connect_sqlite(kg_db_path)

# Add some data
ex = rdflib.Namespace("http://example.org/")
kg.bind_ns("ex", ex)
kg.add((ex.John, rdflib.RDF.type, ex.Person))
kg.add((ex.John, ex.name, rdflib.Literal("John Doe")))
kg.add((ex.John, ex.age, rdflib.Literal(30)))

print(f"Added {len(kg)} triples to SQLite database")

# Run a SPARQL query
q = """
SELECT ?name WHERE {
  ?person a <http://example.org/Person> .
  ?person <http://example.org/name> ?name .
}
"""
results = list(kg.query(q))
print(f"Query result: {results[0][0] if results else 'No results'}")

# Close the connection
kg.close()

# Connect to the same DB with a new graph
kg2 = KnowledgeGraph()
kg2.connect_sqlite(kg_db_path, create=False)
print(f"Loaded graph has {len(kg2)} triples")

# Run the same query
results = list(kg2.query(q))
print(f"Query result after reload: {results[0][0] if results else 'No results'}")

kg2.close()
```

    Added 3 triples to SQLite database
    Query result: John Doe
    Loaded graph has 3 triples
    Query result after reload: John Doe

    KnowledgeGraph(triples=0)
