"""sqlite storage for rdflib knowledge graphs"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../01_sqlite.ipynb.

# %% auto 0
__all__ = ['SQLiteStore']

# %% ../01_sqlite.ipynb
import os
import sqlite3
import rdflib
from rdflib.store import Store, NO_STORE, VALID_STORE
from rdflib import URIRef, Literal, BNode, Graph
from fastcore.all import *
from .core import KnowledgeGraph

# %% ../01_sqlite.ipynb
class SQLiteStore(Store):
    """
    Simple SQLite-based triple store for RDFLib
    """
    
    def __init__(self, configuration=None):
        super(SQLiteStore, self).__init__()
        self.configuration = configuration
        self.conn = None
        self.cursor = None
    
    def open(self, configuration, create=False):
        """
        Open the SQLite database. If create is True, create the 
        database if it doesn't exist.
        """
        if not configuration:
            configuration = self.configuration
        
        if not os.path.exists(configuration) and not create:
            return NO_STORE
        
        self.conn = sqlite3.connect(configuration)
        self.cursor = self.conn.cursor()
        
        # Create tables if needed
        if create:
            self.cursor.execute("""
            CREATE TABLE IF NOT EXISTS triples (
                subject TEXT NOT NULL,
                predicate TEXT NOT NULL,
                object TEXT NOT NULL,
                UNIQUE(subject, predicate, object)
            )
            """)
            
            self.cursor.execute("CREATE INDEX IF NOT EXISTS idx_s ON triples (subject)")
            self.cursor.execute("CREATE INDEX IF NOT EXISTS idx_p ON triples (predicate)")
            self.cursor.execute("CREATE INDEX IF NOT EXISTS idx_o ON triples (object)")
            self.cursor.execute("CREATE INDEX IF NOT EXISTS idx_sp ON triples (subject, predicate)")
            self.cursor.execute("CREATE INDEX IF NOT EXISTS idx_so ON triples (subject, object)")
            self.cursor.execute("CREATE INDEX IF NOT EXISTS idx_po ON triples (predicate, object)")
            
            self.conn.commit()
        
        return VALID_STORE
    
    def close(self, commit_pending_transaction=False):
        """Close the database connection"""
        if commit_pending_transaction:
            self.conn.commit()
        self.conn.close()
        self.conn = None
        self.cursor = None
    
    def _term_to_string(self, term):
        """Convert an RDFLib term to a string for storage"""
        if isinstance(term, URIRef):
            return f"U:{term}"
        elif isinstance(term, BNode):
            return f"B:{term}"
        elif isinstance(term, Literal):
            if term.language:
                return f"L:{term}@{term.language}"
            elif term.datatype:
                return f"L:{term}^^{term.datatype}"
            else:
                return f"L:{term}"
        return str(term)
    
    def _string_to_term(self, string):
        """Convert a stored string back to an RDFLib term"""
        if string.startswith("U:"):
            return URIRef(string[2:])
        elif string.startswith("B:"):
            return BNode(string[2:])
        elif string.startswith("L:"):
            # Handle language tags and datatypes
            if "^^" in string:
                value, datatype = string[2:].rsplit("^^", 1)
                return Literal(value, datatype=URIRef(datatype))
            elif "@" in string:
                value, lang = string[2:].rsplit("@", 1)
                return Literal(value, lang=lang)
            else:
                return Literal(string[2:])
        return string
        
    def add(self, triple, context=None, quoted=False):
        """Add a triple to the store"""
        # Check if connection is open
        if self.cursor is None:
            raise RuntimeError("Database connection is closed")
        
        # We'll ignore the context parameter but raise an error for quoted statements
        if quoted:
            raise NotImplementedError("Quoted statements not supported")
        
        s, p, o = triple
        s_str = self._term_to_string(s)
        p_str = self._term_to_string(p)
        o_str = self._term_to_string(o)
        
        self.cursor.execute(
            "INSERT OR IGNORE INTO triples (subject, predicate, object) VALUES (?, ?, ?)",
            (s_str, p_str, o_str)
        )
        self.conn.commit()

        

    def remove(self, triple_pattern, context=None):
        """Remove triples matching the pattern"""
        # We'll ignore the context parameter
        s, p, o = triple_pattern
        params = []
        where_clauses = []
        
        if s is not None:
            where_clauses.append("subject = ?")
            params.append(self._term_to_string(s))
        
        if p is not None:
            where_clauses.append("predicate = ?")
            params.append(self._term_to_string(p))
        
        if o is not None:
            where_clauses.append("object = ?")
            params.append(self._term_to_string(o))
        
        if where_clauses:
            query = f"DELETE FROM triples WHERE {' AND '.join(where_clauses)}"
            self.cursor.execute(query, params)
        else:
            # Remove all triples if no pattern specified
            self.cursor.execute("DELETE FROM triples")
        
        self.conn.commit()

    def triples(self, triple_pattern, context=None):
        """
        Generator over triples matching the pattern.
        Returns (triple, context) tuples.
        """
        # Check if connection is open
        if self.cursor is None:
            return  # Empty generator if connection is closed
        
        # We'll ignore the context parameter
        s, p, o = triple_pattern
        params = []
        where_clauses = []
        
        if s is not None:
            where_clauses.append("subject = ?")
            params.append(self._term_to_string(s))
        
        if p is not None:
            where_clauses.append("predicate = ?")
            params.append(self._term_to_string(p))
        
        if o is not None:
            where_clauses.append("object = ?")
            params.append(self._term_to_string(o))
        
        if where_clauses:
            query = f"SELECT subject, predicate, object FROM triples WHERE {' AND '.join(where_clauses)}"
        else:
            query = "SELECT subject, predicate, object FROM triples"
        
        self.cursor.execute(query, params)
        
        for s_str, p_str, o_str in self.cursor.fetchall():
            s = self._string_to_term(s_str)
            p = self._string_to_term(p_str)
            o = self._string_to_term(o_str)
            yield (s, p, o), None


    def __len__(self, context=None):
        """Return the number of triples in the store"""
        # We'll ignore the context parameter
        if self.cursor is None:
            return 0  # Return 0 if the connection is closed
        
        self.cursor.execute("SELECT COUNT(*) FROM triples")
        return self.cursor.fetchone()[0]


# %% ../01_sqlite.ipynb
# Register our SQLite store with RDFLib
rdflib.plugin.register(
    'SQLite', rdflib.store.Store,
    'fastkg.sqlite', 'SQLiteStore'
)

# %% ../01_sqlite.ipynb
@patch
def connect_sqlite(self:KnowledgeGraph, db_path, create=True):
    """Connect to a SQLite database file"""
    # Create a new graph with our SQLiteStore directly
    store = SQLiteStore()
    self.g = Graph(store)
    
    # Open the database
    self.g.open(db_path, create=create)
    
    return self


# %% ../01_sqlite.ipynb
@patch
def close(self:KnowledgeGraph):
    """Close the database connection if using a persistent store"""
    if hasattr(self.g.store, 'close'):
        self.g.close()
    return self
